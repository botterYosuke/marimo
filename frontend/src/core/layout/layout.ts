/* Copyright 2026 Marimo. All rights reserved. */

import { useAtomValue } from "jotai";
import { GridLayoutPlugin } from "@/components/editor/renderers/grid-layout/plugin";
import type { GridLayout } from "@/components/editor/renderers/grid-layout/types";
import { cellRendererPlugins } from "@/components/editor/renderers/plugins";
import type { LayoutType } from "@/components/editor/renderers/types";
import { createReducerAndAtoms } from "@/utils/createReducer";
import { Logger } from "@/utils/Logger";
import { repl } from "@/utils/repl";
import { getNotebook } from "../cells/cells";
import type { CellId } from "../cells/ids";
import { notebookCells } from "../cells/utils";
import { is3DModeAtom } from "../mode";
import { store } from "../state/jotai";
import {
  calculateNewCellPlacement,
  DEFAULT_PLACEMENT_CONFIG,
} from "./auto-placement";

export type LayoutData = GridLayout | undefined;

export interface LayoutState {
  selectedLayout: LayoutType;
  layoutData: Partial<Record<LayoutType, LayoutData>>;
  /** Whether auto-layout is enabled for new visual outputs */
  autoLayoutEnabled: boolean;
  /** Whether the current layout was auto-generated (not from a saved file) */
  layoutWasAutoGenerated: boolean;
}

export function initialLayoutState(): LayoutState {
  const is3DMode = store.get(is3DModeAtom);
  return {
    selectedLayout: is3DMode ? "grid" : "vertical",
    layoutData: {},
    autoLayoutEnabled: true,
    layoutWasAutoGenerated: false,
  };
}

const {
  valueAtom: layoutStateAtom,
  useActions,
  reducer: layoutReducer,
} = createReducerAndAtoms(initialLayoutState, {
  setLayoutView: (state, payload: LayoutType) => {
    return {
      ...state,
      selectedLayout: payload,
    };
  },
  setLayoutData: (
    state,
    payload: { layoutView: LayoutType; data: LayoutData },
  ) => {
    return {
      ...state,
      selectedLayout: payload.layoutView,
      layoutData: {
        ...state.layoutData,
        [payload.layoutView]: payload.data,
      },
    };
  },
  setCurrentLayoutData: (state, payload: LayoutData) => {
    return {
      ...state,
      layoutData: {
        ...state.layoutData,
        [state.selectedLayout]: payload,
      },
    };
  },
  setAutoLayoutEnabled: (state, payload: boolean) => {
    return {
      ...state,
      autoLayoutEnabled: payload,
    };
  },
  setLayoutWasAutoGenerated: (state, payload: boolean) => {
    return {
      ...state,
      layoutWasAutoGenerated: payload,
    };
  },
  disableAutoLayout: (state) => {
    return {
      ...state,
      autoLayoutEnabled: false,
      layoutWasAutoGenerated: false,
    };
  },
});

export { layoutStateAtom };

export const useLayoutState = () => {
  return useAtomValue(layoutStateAtom);
};

export const useLayoutActions = () => {
  return useActions();
};

/**
 * Set layout view programmatically. Exposed via repl for testing.
 * Uses the reducer to ensure consistency with useLayoutActions.
 */
function setLayoutViewForTesting(layout: LayoutType) {
  const currentState = store.get(layoutStateAtom);
  const newState = layoutReducer(currentState, {
    type: "setLayoutView",
    payload: layout,
  });
  store.set(layoutStateAtom, newState);
}

// Allow setting layout view from the console for testing
repl(setLayoutViewForTesting, "setLayoutView");

/**
 * Get the serialized layout data, to be used when saving.
 */
export function getSerializedLayout() {
  const notebook = getNotebook();
  const { layoutData, selectedLayout } = store.get(layoutStateAtom);

  // Vertical layout has no data, as it is the default.
  if (selectedLayout === "vertical") {
    return null;
  }

  if (layoutData === undefined) {
    return null;
  }

  const data = layoutData[selectedLayout];
  const plugin = cellRendererPlugins.find(
    (plugin) => plugin.type === selectedLayout,
  );
  if (plugin === undefined) {
    Logger.error(`Unknown layout type: ${selectedLayout}`);
    return null;
  }
  // dataがundefinedの場合はnullを返す
  if (data === undefined) {
    return null;
  }
  return {
    type: selectedLayout,
    data: plugin.serializeLayout(data, notebookCells(notebook)),
  };
}

/**
 * Add a cell to the grid layout with auto-calculated position.
 * Used when a new visual output is detected.
 */
export function addCellToGridLayout(cellId: CellId): void {
  let currentState = store.get(layoutStateAtom);

  // Only works for grid layout
  if (currentState.selectedLayout !== "grid") {
    return;
  }

  let gridLayout = currentState.layoutData.grid;

  // Initialize grid layout if it doesn't exist
  if (!gridLayout) {
    Logger.debug("Grid layout not initialized, creating initial layout");
    gridLayout = GridLayoutPlugin.getInitialLayout([]);
    // Update state with initial layout
    currentState = layoutReducer(currentState, {
      type: "setCurrentLayoutData",
      payload: gridLayout,
    });
    store.set(layoutStateAtom, currentState);
  }

  // Check if cell is already in the grid
  const existingCell = gridLayout.cells.find((c) => c.i === cellId);
  if (existingCell) {
    return;
  }

  // Calculate new position
  const newPosition = calculateNewCellPlacement(
    cellId,
    gridLayout.cells,
    DEFAULT_PLACEMENT_CONFIG,
  );

  // Update layout with new cell
  const newGridLayout: GridLayout = {
    ...gridLayout,
    cells: [...gridLayout.cells, newPosition],
  };

  // Use currentState directly (already updated if initialization occurred)
  const newState = layoutReducer(currentState, {
    type: "setCurrentLayoutData",
    payload: newGridLayout,
  });

  store.set(layoutStateAtom, newState);
}

/**
 * Check if a cell is already in the grid layout
 */
export function isCellInGrid(cellId: CellId): boolean {
  const currentState = store.get(layoutStateAtom);

  if (currentState.selectedLayout !== "grid") {
    return false;
  }

  const gridLayout = currentState.layoutData.grid;
  if (!gridLayout) {
    return false;
  }

  return gridLayout.cells.some((c) => c.i === cellId);
}
