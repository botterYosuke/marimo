---
name: コンテナベースのセル配置に変更
overview: |
  BackcastPro-Steamの方式に合わせて、個別セルを直接CSS2DObjectとしてシーンに追加する方式から、コンテナ全体をCSS2DObjectとしてシーンに追加し、個別セルはコンテナ内に配置する方式に変更します。
todos: []
---

# コンテナベースのセル配置への変更

## 変更の概要

現在の実装では、個別のセル要素を`CSS2DObject`として直接シーンに追加していますが、`BackcastPro-Steam`の方式に合わせて、コンテナ全体を1つの`CSS2DObject`としてシーンに追加し、個別のセルはコンテナ内に配置する方式に変更します。

## 既存実装の参考

以下の既存実装を参考にします：

- [backcast/src/three/cell-css2d-service.ts](backcast/src/three/cell-css2d-service.ts) - コンテナベースの実装例
- `attachCellContainerToScene()` メソッドが既に実装されている
- スケール計算ロジック（`calculateScale()`, `updateContainerScale()`）が実装されている
- `getCurrentScale()` が実装されている（transformスタイルからscale値を抽出）
- [backcast/src/components/editor/renderers/grid-3d-renderer.tsx](backcast/src/components/editor/renderers/grid-3d-renderer.tsx) - コンテナベースの実装パターン
- コンテナ全体を1つのCSS2DObjectとしてシーンに追加
- `createPortal`でコンテナ内にコンテンツをレンダリング

## 主な変更点

### 1. CellCSS2DService の変更

[backcast/src/core/three/cell-css2d-service.ts](backcast/src/core/three/cell-css2d-service.ts) に以下を追加/変更：

- `attachCellContainerToScene(scene: THREE.Scene, position: THREE.Vector3)` メソッドを追加
- `src/three/cell-css2d-service.ts`の実装を参考にする
- コンテナ全体を`CSS2DObject`としてシーンに追加
- デフォルト位置は `(0, 200, 0)`
- `getCSS2DObject()` メソッドを追加
- コンテナのCSS2DObjectを取得するメソッド
- コンテナ位置の取得に使用
- `getContainerPosition()` メソッドを追加（オプション）
- コンテナの3D位置を取得
- セルの相対位置計算に使用
- `setContainerPosition(position: THREE.Vector3)` メソッドを追加（オプション）
- コンテナの3D位置を設定
- 動的な位置変更が必要な場合に使用
- `addCellCSS2DObject()`, `removeCellCSS2DObject()`, `updateCellPosition()` メソッドを削除または非推奨化
- 個別セルのCSS2DObject管理は不要になるため
- `cellCSS2DObjects` Mapを削除
- 個別セルのCSS2DObjectを管理する必要がなくなるため
- `getCellCSS2DObject()` メソッドを削除
- 個別セルのCSS2DObjectを取得する必要がなくなるため
- `getCurrentScale()` メソッドを更新
- `src/three/cell-css2d-service.ts`の実装を参考にする
- transformスタイルからscale値を抽出する実装に変更
- `render()` メソッドを更新
- `src/three/cell-css2d-service.ts`の実装を参考にする
- `updateContainerScale()` を呼び出してコンテナ全体のスケールを更新
- `calculateScale()`, `updateContainerScale()` メソッドを追加
- `src/three/cell-css2d-service.ts`の実装を参考にする
- カメラ距離に基づくスケール計算
- `dispose()` メソッドを更新
- 個別セルのCSS2DObjectを削除する処理（212-217行目）を削除
- 代わりに、コンテナのCSS2DObjectを削除する処理を追加
- `src/three/cell-css2d-service.ts`の実装を参考にする（325-329行目）
- コンテナのCSS2DObjectが存在する場合、シーンから削除
- 実装例：
    ```typescript
        // CSS2DObjectをシーンから削除
        if (this.css2DObject && this.css2DObject.parent) {
          this.css2DObject.parent.remove(this.css2DObject);
        }
        this.css2DObject = undefined;
    ```




### 2. cells-3d-renderer.tsx の変更

[backcast/src/components/editor/renderers/cells-3d-renderer.tsx](backcast/src/components/editor/renderers/cells-3d-renderer.tsx) を大幅に変更：

- コンテナ作成処理を削除（76-112行目）
- `CellCSS2DService.getCellContainer()`から既存のコンテナを取得するのみに変更
- コンテナは`CellCSS2DService.initializeRenderer()`で既に作成されている
- コンテナ取得の前提条件
- `CellCSS2DService.initializeRenderer()`は`edit-app.tsx`で既に呼ばれている
- `getCellContainer()`は常に有効なコンテナを返すことを前提とする
- コンテナが存在しない場合のエラーハンドリングを検討（警告ログを出力するなど）
- コンテナをシーンにアタッチする処理を追加
- `css2DService.attachCellContainerToScene(scene, new THREE.Vector3(0, 200, 0))` を呼び出し
- 初回のみ実行するため、useEffectの依存配列に`scene`を含める
- または、`css2DService.getCSS2DObject()`で既にアタッチされているか確認してから実行
- `attachCellContainerToScene()`は既にコンテナがアタッチされている場合は既存のオブジェクトを削除してから再作成する（`src/three/cell-css2d-service.ts`の実装を参考）
- 実装例：
    ```typescript
        // 既にアタッチされている場合はスキップ
        if (!css2DService.getCSS2DObject()) {
          css2DService.attachCellContainerToScene(scene, new THREE.Vector3(0, 200, 0));
        }
    ```




- セル配置ロジックの変更（114-218行目）
- `css2DService.addCellCSS2DObject()`の呼び出しを削除
- セルの位置を3D座標からCSS座標（left, top）に変換してスタイルで制御
- `updatePositions()`関数を、CSS座標での位置更新に変更
- コンテナの3D位置を基準に、各セルの相対位置を計算
- `handleCellElementReady`コールバックの変更（220-248行目）
- `css2DService.addCellCSS2DObject()`の呼び出しを削除
- セルの位置をCSS座標で設定

### 3. cell-3d-wrapper.tsx の変更（重要）

[backcast/src/components/editor/renderers/cell-3d-wrapper.tsx](backcast/src/components/editor/renderers/cell-3d-wrapper.tsx) を変更：

- `handleTitleBarMouseDown` の変更（62-77行目）
- `css2DService.getCellCSS2DObject(cellId)` の呼び出しを削除
- 代わりに、`cells-3d-renderer.tsx`から位置を取得する方法に変更
- オプション1: `cellPositionsRef`を`CellCSS2DService`経由で取得できるようにする
- オプション2: `CellCSS2DService`に`getCellPosition(cellId: string): THREE.Vector3 | undefined`メソッドを追加
- オプション3: ドラッグ開始時に、セル要素のCSSスタイル（`left`, `top`）から現在位置を取得
- 推奨実装：
  ```typescript
    // セル要素のCSSスタイルから現在位置を取得
    const wrapperElement = wrapperRef.current;
    if (wrapperElement) {
      const left = parseFloat(wrapperElement.style.left) || 0;
      const top = parseFloat(wrapperElement.style.top) || 0;
      // CSS座標を3D座標に変換（コンテナ位置を基準に）
      const containerPosition = css2DService.getContainerPosition() || new THREE.Vector3(0, 200, 0);
      const currentPosition = new THREE.Vector3(
        containerPosition.x + left,
        containerPosition.y,
        containerPosition.z + top
      );
      const scale = css2DService.getCurrentScale();
      dragManager.startDrag(event.nativeEvent, cellId, currentPosition, scale);
      setIsDragging(true);
    }
  ```




### 4. 座標変換の実装詳細

3D空間の座標（`THREE.Vector3`）をCSS座標（`left`, `top`）に変換する必要があります。

#### 座標変換の計算式

- コンテナの3D位置を基準点として使用：`containerPosition = css2DObject.position`（デフォルト: `(0, 200, 0)`）
- 各セルの3D位置（`cellPositionsRef`）からコンテナ位置を引いて相対位置を計算：
  ```typescript
    const relativePosition = new THREE.Vector3(
      cellPosition.x - containerPosition.x,
      cellPosition.y - containerPosition.y,  // 通常は0（Y座標は固定）
      cellPosition.z - containerPosition.z
    );
  ```




- 相対位置をCSS座標（`left`, `top`）に変換：
  ```typescript
    // CSS2DRendererが自動的に3D→2D変換を行うため、直接ピクセル値として使用可能
    // ただし、スケールを考慮する必要がある場合がある
    const left = relativePosition.x;
    const top = relativePosition.z;  // Z軸が上方向（カメラのupベクトルが(0, 0, -1)の場合）
  ```




- CSS `left`, `top`スタイルでセルの位置を設定：
  ```typescript
    wrapperElement.style.left = `${left}px`;
    wrapperElement.style.top = `${top}px`;
  ```




#### 座標変換の注意点

- CSS2DRendererの動作仕様：
- CSS2DRendererは3D空間の位置を2D画面座標に自動変換します
- コンテナ内の要素は、コンテナのCSS2DObjectの位置を基準に配置されます
- セルの`left`/`top`は、コンテナ内での相対位置（ピクセル単位）として設定します
- CSS2DRendererがコンテナ全体の3D→2D変換を行うため、個別セルは相対位置のみを管理します
- 手動での変換は基本的に不要（CSS2DRendererが自動的に処理）
- カメラのupベクトルが`(0, 0, -1)`の場合、Z軸が上方向になるため、`top`は`z`座標を使用
- スケール変換はコンテナ全体に適用されるため、個別セルの位置計算では考慮不要（CSS2DRendererが自動的に処理）

#### セル要素のスタイル設定

- セル要素（`cell-3d-wrapper`）に`position: absolute`を設定する必要がある
- 現在のCSS（`cell-3d-wrapper.css`）では`position: relative`になっているため、`absolute`に変更が必要
- `left`と`top`で位置を制御するため、絶対配置が必須
- CSSファイルの変更：
    ```css
        .cell-3d-wrapper {
          position: absolute;  /* relative から absolute に変更 */
          /* その他のスタイルは維持 */
        }
    ```




### 5. コンテナの3D位置の管理方法

- コンテナの3D位置は固定（デフォルト: `(0, 200, 0)`）とする
- 動的な位置変更が必要な場合は、`CellCSS2DService.setContainerPosition()`を使用
- コンテナ位置を取得する場合は、`CellCSS2DService.getContainerPosition()`を使用
- または、`CellCSS2DService.getCSS2DObject()?.position`から直接取得

### 6. スケール変換の実装詳細

- `src/three/cell-css2d-service.ts`の実装を参考にする
- `calculateScale()`: カメラ距離に基づくスケール計算
- `updateContainerScale()`: コンテナ全体のスケールを更新
- `getCurrentScale()`: transformスタイルからscale値を抽出
- `render()`メソッド内で`updateContainerScale()`を呼び出し

#### スケール変換の影響範囲

- コンテナ全体にスケールが適用されるため、個別セルの位置計算にスケールを考慮する必要があるか確認
- 確認事項：
- ドラッグ時の位置計算でスケールを考慮する必要があるか
    - `CellDragManager`のスケール計算が正しく動作するか
    - ドラッグ開始時に`getCurrentScale()`でスケールを取得し、位置計算に使用（既に実装済み）
- CSS2DRendererが自動的にスケールを適用するため、個別セルの`left`/`top`はスケール前の値で設定可能
- ただし、ドラッグ時のマウス移動量を3D座標に変換する際は、スケールを考慮する必要がある（`CellDragManager`で既に実装済み）

### 7. CellDragManager の詳細な変更内容

[backcast/src/core/three/cell-drag-manager.ts](backcast/src/core/three/cell-drag-manager.ts) の変更：

- `updateCellPosition()`メソッドの削除または非推奨化
- `css2DService.updateCellPosition()`の呼び出しを削除
- 位置更新コールバック（`onPositionUpdate`）の変更
- `cells-3d-renderer.tsx`の`setPositionUpdateCallback`で設定されるコールバックを変更
- コールバック内で、`cellPositionsRef`を更新
- セル要素のCSSスタイル（`left`, `top`）を直接更新
- または、`cellPositionsRef`を更新して、再レンダリング時にCSS座標に変換
- 推奨実装（`cells-3d-renderer.tsx`側）：
  ```typescript
    dragManager.setPositionUpdateCallback((cellId, position) => {
      // 位置を保存
      cellPositionsRef.current.set(cellId, position);
      
      // セル要素のCSSスタイルを更新
      const wrapperElement = cellWrapperElementsRef.current.get(cellId);
      if (wrapperElement) {
        const containerPosition = css2DService.getContainerPosition() || new THREE.Vector3(0, 200, 0);
        const relativePosition = new THREE.Vector3(
          position.x - containerPosition.x,
          position.y - containerPosition.y,
          position.z - containerPosition.z
        );
        wrapperElement.style.left = `${relativePosition.x}px`;
        wrapperElement.style.top = `${relativePosition.z}px`;
      }
      
      // レンダリングをマーク
      sceneManager.markNeedsRender();
      css2DService.markNeedsRender();
    });
  ```




### 8. grid-3d-renderer.tsx との整合性

- `grid-3d-renderer.tsx`は既にコンテナベースの実装になっている
- `cells-3d-renderer.tsx`も同様のパターンに統一する
- コンテナ全体を1つのCSS2DObjectとしてシーンに追加
- `createPortal`でコンテナ内にコンテンツをレンダリング

## 実装の詳細

### パフォーマンスへの影響

- コンテナ全体を1つのCSS2DObjectとして管理することで、オブジェクト数が大幅に減少
- CSS座標での位置更新は、3D座標の更新よりも軽量な可能性がある
- ただし、CSSスタイルの更新はDOM操作になるため、過度な更新は避ける

### テスト計画

以下のテストを実施すべきです：

- `CellCSS2DService`のテスト
- `attachCellContainerToScene()`の動作確認
- `getCurrentScale()`の動作確認
- スケール計算の動作確認
- `cells-3d-renderer.tsx`のテスト
- コンテナの取得とアタッチ
- セルの位置更新（CSS座標）
- 座標変換の正確性
- `cell-3d-wrapper.tsx`のテスト
- ドラッグ開始時の位置取得
- ドラッグ中の位置更新
- `CellDragManager`のテスト
- 位置更新コールバックの動作確認

## 技術的な確認事項

### CSS2DRendererの座標変換の動作確認

計画書の「CSS2DRendererが自動的に3D→2D変換を行う」という記述について、以下を確認：

- コンテナ内の要素の`left`/`top`は、コンテナのCSS2DObjectの位置を基準とした相対位置として解釈されます
- CSS2DRendererはコンテナ全体を3D空間から2D画面に投影します
- 個別セルはコンテナ内での相対位置（ピクセル単位）のみを管理します
- Three.jsのドキュメントでCSS2DRendererの動作仕様を確認（実装前に推奨）

## 注意点

- セルの位置管理方法が3D座標からCSS座標に変わるため、既存の位置データとの互換性を確認
- ドラッグ機能が正常に動作することを確認
- グリッド配置アルゴリズムがCSS座標で正しく動作することを確認
- スケール変換が正しく動作することを確認
- カメラ移動時のスケール更新が正しく動作することを確認
- `cell-3d-wrapper.css`で`position: absolute`が設定されていることを確認（現在は`relative`のため変更が必要）

## 実装前の最終確認

実装前に以下を確認してください：

1. `src/three/cell-css2d-service.ts`の`dispose()`実装を確認（325-329行目）
2. `cell-3d-wrapper.css`で`position: absolute`が設定されているか確認（現在は`relative`のため変更が必要）
3. CSS2DRendererの動作仕様を確認（Three.jsのドキュメント）
4. `edit-app.tsx`で`CellCSS2DService.initializeRenderer()`が呼ばれていることを確認