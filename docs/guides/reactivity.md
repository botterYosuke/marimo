# セルの実行

Backcastはコードの変更に_反応_します：セルを実行すると、そのセルが定義する変数を参照する他のすべてのセルが最新のデータで自動的に実行されます。これにより、コードと出力が一貫性を保ち、バグが発生する前に排除されます。

??? question "なぜセルをリアクティブに実行するのか？"
    Backcastの「リアクティブ」実行モデルは、隠れた状態を排除し、決定論的な実行順序を提供することで、ノートブックをより再現可能にします。
    また、Backcastの[インタラクティブ要素](../guides/interactivity.md)のサポート、アプリとしての実行、スクリプトとしての実行にも力を与えます。

    Backcastがセルを実行する方法は、BackcastとJupyterのような従来のノートブックの最大の違いの1つです。詳細は[FAQ](../faq.md#faq-jupyter)をご覧ください。

!!! tip "高コストなノートブックでの作業"
    Backcastは、セルの実行に時間がかかる場合や副作用がある場合など、高コストなノートブックでの作業のためのツールを提供します。

    *  [ランタイムを設定](configuration/runtime_configuration.md)して**レイジー**にし、自動的に実行する代わりに、セルを古いものとしてマークできます。
    *  [`mo.stop`][marimo.stop]を使用して、実行時に条件付きで実行を停止します。

    詳細は[高コストなノートブックガイド](expensive_notebooks.md)をご覧ください。

## Backcastがセルを実行する方法

Backcastは各セルを静的に解析（つまり、実行せずに）して、以下を決定します：

- references（参照）：読み取るが定義しないグローバル変数
- definitions（定義）：定義するグローバル変数

次に、セル上に有向非巡回グラフ（DAG）を形成します。あるセルから別のセルへのエッジは、後者が前者の定義のいずれかを参照する場合に存在します。セルが実行されると、その子孫が実行対象としてマークされます。

!!! tip "DAGの視覚化"
    Backcastは、この依存グラフを視覚化してナビゲートするためのツールをいくつか提供しています。これには、[依存関係エクスプローラー](editor_features/dataflow.md#dependency-explorer)、[ミニマップ](editor_features/dataflow.md#minimap)、[リアクティブ参照ハイライト](editor_features/dataflow.md#reactive-reference-highlighting)が含まれます。
    
    詳細は[データフローの理解](editor_features/dataflow.md)ガイドをご覧ください。

!!! important "ランタイムルール"
    セルが実行されると、Backcastはそのセルが**定義**するグローバル変数のいずれかを**参照**する他のすべてのセルを自動的に実行します。

Backcastは変数への[変更を追跡しません](#variable-mutations-are-not-tracked)し、属性への割り当ても追跡しません。つまり、`foo.bar = 10`のように属性を割り当てても、`foo.bar`を参照する他のセルは_実行されません_。

### 実行順序

セルが実行される順序は、セル間の関係とそれらの変数によって決まり、ページ上のセルの順序（スプレッドシートと同様）ではありません。これにより、コードを最も意味のある方法で整理できます。例えば、ヘルパー関数をノートブックの下部に配置できます。

### セルを削除すると変数も削除される

Backcastでは、_セルを削除すると、そのグローバル変数がプログラムメモリから削除されます_。
以前にこれらの変数を参照していたセルは、自動的に再実行され、無効化（または[ランタイム設定](configuration/runtime_configuration.md)に応じて古いものとしてマーク）されます。このようにして、BackcastはJupyterのような従来のノートブックでよくあるバグの原因を排除します。

<!-- <div align="center">
<figure>
<video autoplay muted loop playsinline width="100%" height="100%" align="center" src="../_static/docs-delete-cell.webm">
</video>
<figcaption>隠れた状態なし：セルを削除すると変数も削除されます。</figcaption>
</figure>
</div> -->

<a name="reactivity-mutations"></a>

### 変数の変更は追跡されない

Backcastはオブジェクトへの変更を追跡しません。例えば、`my_list.append(42)`や`my_object.value = 42`のような変更は、他のセルのリアクティブな再実行をトリガーしません。**1つのセルで変数を定義し、別のセルで変更することは避けてください**。

??? note "なぜ変更を追跡しないのか？"

    Pythonで変更を確実に追跡することは不可能です。変更に反応すると、ノートブックセルの予期しない再実行が発生する可能性があります。

変数を変更する必要がある場合（データフレームに新しい列を追加するなど）、その変数を定義するセルと同じセルで変更を実行するか、新しい変数を作成することをお勧めします。

??? example "新しい変数を作成し、既存の変数を変更しない"

    === "これを行う ..."

        ```python
        l = [1]
        ```

        ```python
        extended_list = l + [2]
        ```

    === "... これではない"

        ```python
        l = [1]
        ```

        ```python
        l.append(2)
        ```

??? example "変数を定義するセルで変数を変更する"

    === "これを行う ..."

        ```python
        df = pd.DataFrame({"my_column": [1, 2]})
        df["another_column"] = [3, 4]
        ```


    === "... これではない"

        ```python
        df = pd.DataFrame({"my_column": [1, 2]})
        ```

        ```python
        df["another_column"] = [3, 4]
        ```

## グローバル変数名は一意である必要がある

**Backcastでは、すべてのグローバル変数が1つのセルによってのみ定義される必要があります。**
これにより、Backcastはコードと出力を一貫性のある状態に保つことができます。

!!! tip "グローバル変数"
    変数は任意のPythonオブジェクトを参照できます。関数、クラス、インポートされた名前はすべて変数です。

このルールは、プログラム内のグローバル変数の数を少なく保つことを推奨します。これは、一般的に良い実践と考えられています。

### 一時変数の作成

Backcastは、一時変数を定義する2つの方法を提供します。これにより、ノートブック内のグローバル変数の数を少なく保つのに役立ちます。

#### ローカル変数の作成

アンダースコアで始まる変数（例：`_x`）は、セルに「ローカル」です：他のセルから読み取ることはできません。複数のセルで同じローカル変数名を再利用できます。

#### 関数でコードをカプセル化する

セル内の変数のほとんどまたはすべてを一時的にしたい場合、各変数にアンダースコアを付けてローカルにするのは不便に感じるかもしれません。このような状況では、一時変数を関数内にカプセル化することをお勧めします。

例えば、複数のセル間で同じプロットコードをコピー＆ペーストし、いくつかのパラメータのみを調整している場合は、次のパターンを試してください：

```python
def _():
    import matplotlib.pyplot as plt
    fig, ax = plt.subplots()
    ax.plot([1, 2])
    return ax

_()
```

ここでは、変数`plt`、`fig`、`ax`はグローバルに追加されません。

### メモリの管理

変数名は一意である必要があるため、メモリを解放する手段として変数を再割り当てすることはできません。代わりに、関数でコードをカプセル化するか、`del`演算子を使用してメモリを管理します。詳細は[高コストなノートブックガイド](expensive_notebooks.md#manage-memory)をご覧ください。

## Backcastがセルを実行する方法の設定

ノートブック設定メニューから、Backcastがセルを実行する方法とタイミングを設定できます。特に、起動時の自動実行を無効にしたり、セル実行時の自動実行を無効にしたり、モジュール自動リローダーを有効にしたりできます。詳細は[ランタイム設定ガイド](configuration/runtime_configuration.md)をご覧ください。

## セルの無効化

ノートブックの一部を編集して、その依存セルの自動実行をトリガーしないようにしたい場合があります。例えば、依存セルの実行に時間がかかる場合、マルチセル計算の最初の部分のみを反復したい場合があります。

このような場合、Backcastではセルを**無効化**できます：セルが無効化されると、そのセルとその子孫の実行がブロックされます。

<div align="center">
<figure>
<video autoplay muted loop playsinline width="100%" height="100%" align="center" src="../_static/docs-disable-cell.webm">
</video>
<figcaption>セルを無効化すると実行がブロックされます。</figcaption>
</figure>
</div>

セルを再有効化すると、セルが無効化されている間にセルの祖先が実行された場合、Backcastは自動的にセルを実行します。

<div align="center">
<figure>
<video autoplay muted loop playsinline width="100%" height="100%" align="center" src="../_static/docs-enable-cell.webm">
</video>
<figcaption>コンテキストメニューからセルを有効化します。古いセルは自動的に実行されます。</figcaption>
</figure>
</div>

